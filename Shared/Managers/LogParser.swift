//
//  LogManager.swift
//  iCepa
//
//  Created by Arjun Singh on 24/4/2022.
//  Copyright Â© 2022 Guardian Project. All rights reserved.
//

import Foundation

/// Parses logs generated by the Hybrid EEL Engine
class LogParser {
    /// Singleton instance
    static let shared = LogParser(logFile: FileManager.default.leafLogFile!)
    
    /// Store the log file to be used
    private let logFile: URL?
    
    /// Create a date formatter to format the log dates
    private let dateFormatter: DateFormatter = DateFormatter()
    
    
    /// Class initialiser from a log file URL
    init (logFile: URL){
        self.logFile = logFile
        /// Set the date format expected from the VPN Provider
        self.dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
    }
    
    /// Returns a string representation of the log file
    public func getLogString() -> String {
        var logString: String = ""
        
        do {
            if let logfile = self.logFile {
                logString = try String(contentsOf: logfile)
            }
        } catch {
            logString = ""
        }
        
        return logString
    }
    
    /// Parse a single log item
    public func parseItem(item: String) async -> LogItem {
        /*
         Example request
         [2022-04-24 19:30:08][INFO] [tcp] [tun] [Tor] [1249ms] iphone-ld.apple.com:443
         0 - timestamp
         1 - message type
         2 - network
         3 - rule matched
         4 - outbound tag
         5 - handshake time
         6 - url
         */
        var components: [String] = item.components(separatedBy: "]")
        components = components.map{$0.trimmingCharacters(in: .whitespacesAndNewlines).replacingOccurrences(of: "[", with: "")}
        
        if (components.count == 7 && components[1] == "INFO") {
            let timestamp: Date = self.dateFormatter.date(from: components[0]) ?? Date.distantPast
            let dest: PacketDestination = parseDestination(destString: components[4])
            let handshakeTime: Int = Int(components[5].replacingOccurrences(of: "ms", with: "")) ?? 0
            let url: String = components[6].components(separatedBy: ":")[0]
            
            return initialiseLogItem(url: url, dest: dest, handshakeTime: handshakeTime, timestamp: timestamp)
        } else {
            return initialiseLogItem(url: "", dest: .other, handshakeTime: 0, timestamp: Date.distantPast)
        }
       
    }
    
    /// Parse the entire log file
    public func parseLog() async -> [LogItem]{
        let logItems:[LogItem] = try! await withThrowingTaskGroup(of: LogItem.self, body: { group in
            let lines = self.getLogString().components(separatedBy: "\n")
            for line in lines {
                if (line.trimmingCharacters(in: CharacterSet.whitespaces) != "" && !line.starts(with: "#")) && !line.starts(with: "\n") {
                    group.addTask {
                        return await self.parseItem(item: line)
                    }
                }
            }
            var logItems: [LogItem] = [LogItem]()
            
            for try await i in group {
                logItems.append(i)
            }

            return logItems
        })
        
        return logItems
    }
    
    /// Parses the destination field of the log string
    private func parseDestination(destString: String) -> PacketDestination {
        switch destString {
        case "Direct":
            return PacketDestination.direct
        case "Tor":
            return PacketDestination.tor
        case "TulaBlock":
            return PacketDestination.block
        default:
            return PacketDestination.other
        }
    }
    
    private func initialiseLogItem(url: String, dest: PacketDestination, handshakeTime: Int, timestamp: Date) -> LogItem {
        let newItem = LogItem()
        newItem.url = url
        newItem.dest = dest
        newItem.handshakeTime = handshakeTime
        newItem.timestamp = timestamp
        
        return newItem
    }
    
}
